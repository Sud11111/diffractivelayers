# -*- coding: utf-8 -*-
"""mk-6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dcrSpIeINzfX2owT-FwRS006IOBNPeiR
"""

import tensorflow as tf
import tensorflow_datasets as tfds
import numpy as np
from tensorflow import keras
import tensorflow.signal as fft
import os
import matplotlib.pyplot as plt
strategy=tf.distribute.MirroredStrategy()
with strategy.scope():

    class AngularSpectrumPropagator(keras.layers.Layer):
        def __init__(self, extent, z):
            super(AngularSpectrumPropagator, self).__init__()
            self.位      =   tf.constant(600e-9)
            self.extent =   extent*self.位
            self.z      =   z*self.位
            
        def build(self, input_dim):
            self.E  = tf.Variable(initial_value=tf.zeros((input_dim[-2],input_dim[-1])), trainable=False)    
            self.Nx = input_dim[-2]
            self.Ny = input_dim[-1]

        def call(self, inputs):
            fft_c       = tf.signal.fft2d(tf.cast(inputs,tf.complex128))
            c           = fft.fftshift(fft_c)
            dx          = tf.math.divide(self.extent, tf.cast(self.Nx, tf.float32) )
            dy          = tf.math.divide(self.extent, tf.cast(self.Ny, tf.float32) )
            fx          = fft.fftshift(np.fft.fftfreq(int(self.Nx), d = dx))
            fy          = fft.fftshift(np.fft.fftfreq(int(self.Ny), d = dy))
            fxx, fyy    = tf.meshgrid(tf.cast(fx, tf.double), tf.cast(fy, tf.double))
            argument    = (2 * np.pi)**2 * ((1. / self.位) ** 2 -tf.cast(fxx, tf.float32)** 2 -tf.cast(fyy, tf.float32)** 2)
            #Calculate the propagating and the evanescent (complex) modes
            tmp     = tf.math.sqrt(tf.math.abs(argument))
            kz      = tf.where(argument >= 0, tf.cast(tmp, tf.complex128), 1j*tf.cast(tmp, tf.complex128))
            # propagate the angular spectrum a distance z
            h=tf.where(argument >= 0, tf.math.exp(1j * tf.cast(tmp, tf.complex128) * tf.cast(self.z, tf.complex128)),0)
            self.E  = tf.signal.ifft2d(fft.ifftshift(c * h))
            #self.E  = tf.signal.ifft2d(fft.ifftshift(c * tf.math.exp(1j * kz * tf.cast(self.z, tf.complex128))))

            return self.E

    class DiffractiveLayer(keras.layers.Layer):
        def __init__(self, input_dim=(200,200)):
            super(DiffractiveLayer, self).__init__()
        def build(self, input_dim):
            self.phase = self.add_weight(
                shape=(input_dim[-1],input_dim[-2]), initializer="random_normal", trainable=True, constraint="NonNeg",name='layer'
            )
        def call(self, inputs):
            return tf.math.multiply(tf.cast(inputs,tf.complex128), tf.math.exp(1j*tf.cast(self.phase,tf.complex128)))

    class TotalLoss(tf.keras.losses.Loss):
        def __init__(self):
            super().__init__()
        def call(self, y_true, y_pred):
            lpixel=     tf.reduce_mean(tf.math.abs(tf.math.subtract(y_true, y_pred)))
            lfourier=   tf.reduce_mean(tf.math.square(tf.math.abs(tf.math.subtract(tf.signal.fft2d(tf.cast(y_true, tf.complex128)), tf.signal.fft2d(tf.cast(y_pred, tf.complex128))))))
            leffec=     1-tf.math.divide(tf.reduce_mean(y_pred),1)
            return lpixel+1000*lfourier+0.5*leffec

(ds_train, ds_test), ds_info = tfds.load(
    'emnist',
    download=False,
    data_dir='/home/sudhanshus.phy20.itbhu/tensorflow_datasets/',
    split=['train[:110000]', 'test[:10000]'],
    shuffle_files=True,
    as_supervised=True,
    with_info=True,
)

def preprocess(image, label):
    #resize 0-255 28*28 to 0-25x 50*50
    image= tf.image.resize(image, (50, 50), method='bilinear')
    image=tf.squeeze(image)
    #normalize 0-25x 50*50 to 0-1 50*50 
    image = tf.cast(image, tf.float32) / tf.reduce_max(image)
    #pad 0-1 50*50 to 0-1 200*200
    paddings=tf.constant([[75,75],[75,75]])
    image=tf.pad(image, paddings, 'CONSTANT')
    #invert 0-1 200*200 to 1-0 200*200 transperancy matrix
    image=tf.math.subtract(1.0, image)
    '''putting the transparency matrix into angular spectrum method
     to obtain hologram''' 
    hologram=tf.math.square(tf.math.abs(AngularSpectrumPropagator(100, 30)(image)))
    '''normalizing hologram to obtain the transperancy matrix corresponding to hologram'''
    hologram = tf.math.divide(tf.cast(hologram, tf.float32), tf.cast(tf.reduce_max(hologram),tf.float32))
    hologram1=hologram[58:142,58:142]
    holopad=tf.constant([[58,58],[58,58]])
    hologram2=tf.pad(hologram1,holopad,'CONSTANT',constant_values=1)
    return hologram2, image

ds_train=   ds_train.map(
                preprocess, num_parallel_calls=tf.data.AUTOTUNE
            )
ds_train =  ds_train.cache()
ds_train =  ds_train.shuffle(ds_info.splits['train'].num_examples)
ds_train=   ds_train.batch(8)
ds_train =  ds_train.prefetch(tf.data.AUTOTUNE)
ds_train

ds_test =   ds_test.map(
                preprocess, num_parallel_calls=tf.data.AUTOTUNE
            )
ds_test =   ds_test.batch(8)
ds_test =   ds_test.cache()
ds_test =   ds_test.prefetch(tf.data.AUTOTUNE)
ds_test
with strategy.scope():

    model=tf.keras.models.Sequential(
    [   AngularSpectrumPropagator(100, 37.5),
        DiffractiveLayer(),
        AngularSpectrumPropagator(100, 37.5),
        DiffractiveLayer(),
        AngularSpectrumPropagator(100, 37.5),
        DiffractiveLayer(),
        AngularSpectrumPropagator(100, 37.5),
        DiffractiveLayer(),
        AngularSpectrumPropagator(100, 37.5),
        DiffractiveLayer(),   
        tf.keras.layers.Lambda(lambda x: tf.square(tf.abs(x)))]
    )
    loss_fn=TotalLoss()
model.compile(  optimizer =  'Adam',
                loss =       loss_fn
)

model.fit(ds_train, epochs=50)
model.summary
model.save(filepath='./try22')
